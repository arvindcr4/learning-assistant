import { NextRequest, NextResponse } from 'next/server';
import { withSecureAuth, AuthenticatedRequest } from '@/middleware/secure-auth';
import { z } from 'zod';
import { rotationManager, secretsManager } from '@/lib/secrets';
import { validateRequest, createSanitizedStringSchema } from '@/app/api/schemas/validation';

// Request schemas with enhanced validation
const RotateSecretSchema = z.object({
  secretName: createSanitizedStringSchema(100, 'Secret name too long').regex(
    /^[a-zA-Z0-9_-]+$/, 
    'Secret name can only contain alphanumeric characters, underscores, and hyphens'
  ),
  force: z.boolean().optional().default(false),
  reason: createSanitizedStringSchema(500, 'Reason too long').optional(),
});

const EmergencyRotateSchema = z.object({
  reason: createSanitizedStringSchema(500, 'Reason too long').min(10, 'Emergency reason must be at least 10 characters'),
  confirm: z.literal(true, { errorMap: () => ({ message: 'Emergency rotation must be confirmed' }) }),
  notificationWebhook: z.string().url('Invalid webhook URL').optional(),
});

async function handlePost(request: AuthenticatedRequest): Promise<NextResponse> {
  try {
    // Only admin and security personnel can rotate secrets
    if (!['admin', 'security_team', 'security_analyst'].includes(request.user!.role)) {
      return NextResponse.json({
        success: false,
        error: 'Insufficient permissions',
        message: 'Only admin and security personnel can rotate secrets',
        code: 'INSUFFICIENT_PERMISSIONS',
      }, { status: 403 });
    }

    const body = await request.json();
    const url = new URL(request.url);
    const action = url.searchParams.get('action') || 'rotate';

    // Validate action parameter
    if (!['rotate', 'emergency'].includes(action)) {
      return NextResponse.json({
        success: false,
        error: 'Invalid action',
        message: 'Supported actions: rotate, emergency',
        code: 'INVALID_ACTION',
      }, { status: 400 });
    }

    switch (action) {
      case 'rotate':
        return await handleSecretRotation(body, request.user!.id);
      
      case 'emergency':
        return await handleEmergencyRotation(body, request.user!.id);
      
      default:
        return NextResponse.json({
          success: false,
          error: 'Invalid action',
          message: 'Supported actions: rotate, emergency',
          code: 'INVALID_ACTION',
        }, { status: 400 });
    }

  } catch (error) {
    console.error('Secret rotation API error:', error);

    if (error instanceof z.ZodError) {
      return NextResponse.json({
        success: false,
        error: 'Validation error',
        details: error.errors,
        code: 'VALIDATION_ERROR',
      }, { status: 400 });
    }

    return NextResponse.json({
      success: false,
      error: 'Internal server error',
      message: error instanceof Error ? error.message : 'Unknown error',
      code: 'INTERNAL_ERROR',
    }, { status: 500 });
  }
}

async function handleSecretRotation(body: any, userId: string) {
  const validatedData = validateRequest(RotateSecretSchema, body);
  const { secretName, force, reason } = validatedData;

  try {
    // Check if secret exists and get current status
    const rotationStatus = rotationManager.getRotationStatus(secretName);
    
    if (!rotationStatus) {
      return NextResponse.json({
        success: false,
        error: 'Secret not found',
        message: `No rotation policy found for secret: ${secretName}`,
      }, { status: 404 });
    }

    // Check if rotation is needed (unless forced)
    if (!force && rotationStatus.lastRun) {
      const lastRun = new Date(rotationStatus.lastRun);
      const intervalMs = rotationStatus.policy.interval * 24 * 60 * 60 * 1000; // days to ms
      const nextRotation = new Date(lastRun.getTime() + intervalMs);
      
      if (new Date() < nextRotation) {
        return NextResponse.json({
          success: false,
          error: 'Rotation not due',
          message: `Secret rotation not due until ${nextRotation.toISOString()}`,
          data: {
            lastRotation: rotationStatus.lastRun,
            nextRotation: nextRotation.toISOString(),
            intervalDays: rotationStatus.policy.interval,
          },
        }, { status: 400 });
      }
    }

    // Perform rotation
    console.log(`Starting manual rotation for secret: ${secretName} (user: ${userId}, reason: ${reason})`);
    
    const result = await rotationManager.manualRotation(secretName);

    // Log the rotation attempt
    if (reason) {
      console.log(`Rotation reason: ${reason}`);
    }

    return NextResponse.json({
      success: result.success,
      data: {
        secretName,
        result,
        rotatedBy: userId,
        reason,
        timestamp: new Date().toISOString(),
      },
      message: result.success 
        ? `Secret ${secretName} rotated successfully`
        : `Secret rotation failed: ${result.error}`,
    }, { status: result.success ? 200 : 500 });

  } catch (error) {
    console.error(`Failed to rotate secret ${secretName}:`, error);

    return NextResponse.json({
      success: false,
      error: 'Rotation failed',
      message: error instanceof Error ? error.message : 'Unknown error',
      data: {
        secretName,
        rotatedBy: userId,
        reason,
        timestamp: new Date().toISOString(),
      },
    }, { status: 500 });
  }
}

async function handleEmergencyRotation(body: any, userId: string) {
  const validatedData = validateRequest(EmergencyRotateSchema, body);
  const { reason, confirm, notificationWebhook } = validatedData;

  try {
    console.log(`ðŸš¨ EMERGENCY ROTATION INITIATED by ${userId}: ${reason}`);

    // Log emergency rotation start
    const emergencyLog = {
      event: 'emergency_rotation_started',
      initiatedBy: userId,
      reason,
      timestamp: new Date().toISOString(),
    };

    console.log('Emergency rotation log:', JSON.stringify(emergencyLog, null, 2));

    // Send notification if webhook provided
    if (notificationWebhook) {
      try {
        await fetch(notificationWebhook, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            ...emergencyLog,
            alert: 'Emergency secret rotation in progress',
          }),
        });
      } catch (webhookError) {
        console.error('Failed to send emergency notification:', webhookError);
      }
    }

    // Perform emergency rotation
    const results = await rotationManager.emergencyRotateAll();

    // Count successes and failures
    const successful = results.filter(r => r.success).length;
    const failed = results.filter(r => !r.success).length;

    const emergencyCompleteLog = {
      event: 'emergency_rotation_completed',
      initiatedBy: userId,
      reason,
      successful,
      failed,
      total: results.length,
      timestamp: new Date().toISOString(),
    };

    console.log('Emergency rotation complete:', JSON.stringify(emergencyCompleteLog, null, 2));

    // Send completion notification
    if (notificationWebhook) {
      try {
        await fetch(notificationWebhook, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            ...emergencyCompleteLog,
            alert: failed > 0 
              ? `Emergency rotation completed with ${failed} failures`
              : 'Emergency rotation completed successfully',
          }),
        });
      } catch (webhookError) {
        console.error('Failed to send completion notification:', webhookError);
      }
    }

    return NextResponse.json({
      success: failed === 0,
      data: {
        results,
        summary: {
          total: results.length,
          successful,
          failed,
        },
        initiatedBy: userId,
        reason,
        timestamp: new Date().toISOString(),
      },
      message: failed === 0 
        ? `Emergency rotation completed successfully (${successful} secrets rotated)`
        : `Emergency rotation completed with ${failed} failures out of ${results.length} secrets`,
    }, { status: failed === 0 ? 200 : 207 }); // 207 = Multi-Status for partial success

  } catch (error) {
    console.error('Emergency rotation failed:', error);

    const errorLog = {
      event: 'emergency_rotation_failed',
      initiatedBy: userId,
      reason,
      error: error instanceof Error ? error.message : 'Unknown error',
      timestamp: new Date().toISOString(),
    };

    console.log('Emergency rotation error:', JSON.stringify(errorLog, null, 2));

    // Send error notification
    if (notificationWebhook) {
      try {
        await fetch(notificationWebhook, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            ...errorLog,
            alert: 'Emergency rotation failed - immediate attention required',
          }),
        });
      } catch (webhookError) {
        console.error('Failed to send error notification:', webhookError);
      }
    }

    return NextResponse.json({
      success: false,
      error: 'Emergency rotation failed',
      message: error instanceof Error ? error.message : 'Unknown error',
      data: {
        initiatedBy: userId,
        reason,
        timestamp: new Date().toISOString(),
      },
    }, { status: 500 });
  }
}

async function handleGet(request: AuthenticatedRequest): Promise<NextResponse> {
  try {
    // Only admin and security personnel can view rotation status
    if (!['admin', 'security_team', 'security_analyst'].includes(request.user!.role)) {
      return NextResponse.json({
        success: false,
        error: 'Insufficient permissions',
        message: 'Only admin and security personnel can view rotation status',
        code: 'INSUFFICIENT_PERMISSIONS',
      }, { status: 403 });
    }

    const url = new URL(request.url);
    const action = url.searchParams.get('action') || 'status';
    const secretName = url.searchParams.get('secret');

    // Validate secret name if provided
    if (secretName && !/^[a-zA-Z0-9_-]+$/.test(secretName)) {
      return NextResponse.json({
        success: false,
        error: 'Invalid secret name format',
        message: 'Secret name can only contain alphanumeric characters, underscores, and hyphens',
        code: 'INVALID_SECRET_NAME',
      }, { status: 400 });
    }

    switch (action) {
      case 'status':
        if (secretName) {
          // Get status for specific secret
          const status = rotationManager.getRotationStatus(secretName);
          if (!status) {
            return NextResponse.json({
              success: false,
              error: 'Secret not found',
              code: 'SECRET_NOT_FOUND',
            }, { status: 404 });
          }
          
          return NextResponse.json({
            success: true,
            data: status,
          });
        } else {
          // Get status for all secrets
          const jobs = rotationManager.getRotationJobs();
          return NextResponse.json({
            success: true,
            data: jobs,
          });
        }

      case 'history':
        if (!secretName) {
          return NextResponse.json({
            success: false,
            error: 'Secret name required for history',
            code: 'SECRET_NAME_REQUIRED',
          }, { status: 400 });
        }
        
        const history = rotationManager.getRotationHistory(secretName);
        return NextResponse.json({
          success: true,
          data: history,
        });

      default:
        return NextResponse.json({
          success: false,
          error: 'Invalid action',
          message: 'Supported actions: status, history',
          code: 'INVALID_ACTION',
        }, { status: 400 });
    }

  } catch (error) {
    console.error('Secret rotation GET API error:', error);

    return NextResponse.json({
      success: false,
      error: 'Internal server error',
      message: error instanceof Error ? error.message : 'Unknown error',
      code: 'INTERNAL_ERROR',
    }, { status: 500 });
  }
}

// Export with secure authentication middleware
export const POST = withSecureAuth(handlePost, {
  requiredRoles: ['admin', 'security_team', 'security_analyst'],
  rateLimits: {
    maxRequestsPerUser: 5, // Very limited secret rotation attempts
    maxRequestsPerIP: 2,
    windowMs: 60 * 60 * 1000, // 1 hour
  },
});

export const GET = withSecureAuth(handleGet, {
  requiredRoles: ['admin', 'security_team', 'security_analyst'],
  rateLimits: {
    maxRequestsPerUser: 30,
    maxRequestsPerIP: 15,
    windowMs: 60000, // 1 minute
  },
});