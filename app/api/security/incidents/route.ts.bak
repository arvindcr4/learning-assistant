import { NextRequest, NextResponse } from 'next/server';
import { withSecureAuth, AuthenticatedRequest } from '@/middleware/secure-auth';
import { incidentResponseService } from '@/lib/security/incident-response';
import { z } from 'zod';

const createIncidentSchema = z.object({
  title: z.string().min(1).max(200),
  description: z.string().min(1).max(2000),
  severity: z.enum(['low', 'medium', 'high', 'critical']),
  category: z.enum(['data_breach', 'malware', 'unauthorized_access', 'ddos', 'phishing', 'insider_threat', 'other']),
  discoveredAt: z.string().datetime().optional(),
  affectedSystems: z.array(z.string()).optional().default([]),
  affectedUsers: z.array(z.string()).optional().default([]),
  evidenceUrls: z.array(z.string().url()).optional().default([]),
  tags: z.array(z.string()).optional().default([]),
  confidentiality: z.enum(['public', 'internal', 'confidential', 'restricted']).optional().default('internal'),
});

const updateStatusSchema = z.object({
  status: z.enum(['open', 'investigating', 'contained', 'resolved', 'closed']),
  notes: z.string().max(1000).optional(),
});

const addActionSchema = z.object({
  type: z.enum(['immediate', 'short_term', 'long_term', 'preventive']),
  description: z.string().min(1).max(500),
  assignedTo: z.string().optional(),
  dueDate: z.string().datetime().optional(),
  priority: z.enum(['low', 'medium', 'high', 'critical']),
});

async function handlePost(request: AuthenticatedRequest) {
  try {
    const body = await request.json();
    const incidentData = createIncidentSchema.parse(body);
    
    const userId = request.user!.id;
    
    // Only security team and admins can create incidents
    if (!['admin', 'security_team', 'security_analyst'].includes(request.user!.role)) {
      return NextResponse.json(
        { 
          error: 'Insufficient permissions to create incidents',
          code: 'INSUFFICIENT_PERMISSIONS'
        },
        { status: 403 }
      );
    }
    
    const incidentId = incidentResponseService.createIncident({
      ...incidentData,
      discoveredAt: incidentData.discoveredAt ? new Date(incidentData.discoveredAt) : new Date(),
      reporter: userId,
      relatedEvents: [],
      relatedAlerts: [],
      priority: incidentData.severity === 'critical' ? 'critical' : 
                incidentData.severity === 'high' ? 'high' : 
                incidentData.severity === 'medium' ? 'medium' : 'low',
    });
    
    return NextResponse.json({
      success: true,
      message: 'Security incident created successfully',
      data: {
        incidentId,
        status: 'open',
      },
    });
  } catch (error) {
    console.error('Incident creation error:', error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { 
          error: 'Invalid incident data',
          details: error.errors,
          code: 'VALIDATION_ERROR'
        },
        { status: 400 }
      );
    }
    
    return NextResponse.json(
      { 
        error: 'Failed to create incident',
        code: 'INCIDENT_CREATION_ERROR'
      },
      { status: 500 }
    );
  }
}

async function handleGet(request: AuthenticatedRequest) {
  try {
    const { searchParams } = new URL(request.url);
    
    // Only security team and admins can view incidents
    if (!['admin', 'security_team', 'security_analyst'].includes(request.user!.role)) {
      return NextResponse.json(
        { 
          error: 'Insufficient permissions to view incidents',
          code: 'INSUFFICIENT_PERMISSIONS'
        },
        { status: 403 }
      );
    }
    
    // Parse query parameters
    const filters: any = {};
    
    if (searchParams.get('status')) {
      filters.status = searchParams.get('status');
    }
    if (searchParams.get('severity')) {
      filters.severity = searchParams.get('severity');
    }
    if (searchParams.get('category')) {
      filters.category = searchParams.get('category');
    }
    if (searchParams.get('assignedTo')) {
      filters.assignedTo = searchParams.get('assignedTo');
    }
    if (searchParams.get('limit')) {
      filters.limit = parseInt(searchParams.get('limit') || '50');
    }
    
    // Date range filter
    const startDate = searchParams.get('startDate');
    const endDate = searchParams.get('endDate');
    if (startDate && endDate) {
      filters.dateRange = {
        start: new Date(startDate),
        end: new Date(endDate),
      };
    }
    
    const incidents = incidentResponseService.getIncidents(filters);
    const metrics = incidentResponseService.getIncidentMetrics();
    
    // Remove sensitive information for non-admin users
    const sanitizedIncidents = incidents.map(incident => {
      if (request.user!.role !== 'admin' && incident.confidentiality === 'restricted') {
        return {
          id: incident.id,
          title: '[RESTRICTED]',
          severity: incident.severity,
          status: incident.status,
          category: incident.category,
          createdAt: incident.createdAt,
        };
      }
      
      return {
        id: incident.id,
        title: incident.title,
        description: incident.description,
        severity: incident.severity,
        status: incident.status,
        category: incident.category,
        priority: incident.priority,
        createdAt: incident.createdAt,
        updatedAt: incident.updatedAt,
        discoveredAt: incident.discoveredAt,
        containedAt: incident.containedAt,
        resolvedAt: incident.resolvedAt,
        assignedTo: incident.assignedTo,
        reporter: incident.reporter,
        affectedSystems: incident.affectedSystems,
        affectedUsers: incident.affectedUsers.length, // Only count, not actual users
        tags: incident.tags,
        confidentiality: incident.confidentiality,
      };
    });
    
    return NextResponse.json({
      success: true,
      data: {
        incidents: sanitizedIncidents,
        metrics: {
          total: metrics.total,
          byStatus: metrics.byStatus,
          bySeverity: metrics.bySeverity,
          byCategory: metrics.byCategory,
          averageTimeToContainment: Math.round(metrics.averageTimeToContainment),
          averageTimeToResolution: Math.round(metrics.averageTimeToResolution),
        },
        pagination: {
          total: incidents.length,
          limit: filters.limit || 50,
        },
      },
    });
  } catch (error) {
    console.error('Incident retrieval error:', error);
    
    return NextResponse.json(
      { 
        error: 'Failed to retrieve incidents',
        code: 'INCIDENT_RETRIEVAL_ERROR'
      },
      { status: 500 }
    );
  }
}

export const POST = withSecureAuth(handlePost, {
  requiredRoles: ['admin', 'security_team', 'security_analyst'],
  rateLimits: {
    maxRequestsPerUser: 10,
    maxRequestsPerIP: 5,
    windowMs: 60000, // 1 minute
  },
});

export const GET = withSecureAuth(handleGet, {
  requiredRoles: ['admin', 'security_team', 'security_analyst'],
  rateLimits: {
    maxRequestsPerUser: 60,
    maxRequestsPerIP: 30,
    windowMs: 60000, // 1 minute
  },
});