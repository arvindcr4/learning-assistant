#!/bin/bash

# ==============================================================================\n# INFRASTRUCTURE AUTOMATION SCRIPT\n# Comprehensive DevOps infrastructure management and deployment automation\n# ==============================================================================\n\nset -euo pipefail\n\n# Global Configuration\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nPROJECT_ROOT=\"$(cd \"$SCRIPT_DIR/../..\" && pwd)\"\nLOG_DIR=\"$PROJECT_ROOT/logs\"\nDATE=$(date +\"%Y%m%d_%H%M%S\")\nLOG_FILE=\"$LOG_DIR/infrastructure_automation_$DATE.log\"\n\n# Ensure log directory exists\nmkdir -p \"$LOG_DIR\"\n\n# Colors for output\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nBLUE='\\033[0;34m'\nPURPLE='\\033[0;35m'\nCYAN='\\033[0;36m'\nNC='\\033[0m' # No Color\n\n# Logging function\nlog() {\n    local level=\"$1\"\n    shift\n    local message=\"$*\"\n    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')\n    echo \"[$timestamp] [$level] $message\" | tee -a \"$LOG_FILE\"\n}\n\ninfo() { log \"INFO\" \"$@\"; }\nwarn() { log \"WARN\" \"$@\"; }\nerror() { log \"ERROR\" \"$@\"; }\nsuccess() { log \"SUCCESS\" \"$@\"; }\n\n# Pretty print functions\nprint_header() {\n    echo -e \"${BLUE}=================================================================================${NC}\"\n    echo -e \"${BLUE}$1${NC}\"\n    echo -e \"${BLUE}=================================================================================${NC}\"\n}\n\nprint_step() {\n    echo -e \"${CYAN}âž¤ $1${NC}\"\n}\n\nprint_success() {\n    echo -e \"${GREEN}âœ… $1${NC}\"\n}\n\nprint_error() {\n    echo -e \"${RED}âŒ $1${NC}\"\n}\n\nprint_warning() {\n    echo -e \"${YELLOW}âš ï¸  $1${NC}\"\n}\n\n# Configuration validation\nvalidate_config() {\n    print_step \"Validating configuration...\"\n    \n    local required_vars=(\n        \"ENVIRONMENT\"\n        \"CLOUD_PROVIDER\"\n        \"KUBERNETES_CLUSTER\"\n        \"DOMAIN_NAME\"\n    )\n    \n    for var in \"${required_vars[@]}\"; do\n        if [[ -z \"${!var:-}\" ]]; then\n            print_error \"Required environment variable $var is not set\"\n            return 1\n        fi\n    done\n    \n    print_success \"Configuration validation passed\"\n}\n\n# Tool availability check\ncheck_tools() {\n    print_step \"Checking required tools...\"\n    \n    local tools=(\n        \"kubectl:https://kubernetes.io/docs/tasks/tools/\"\n        \"helm:https://helm.sh/docs/intro/install/\"\n        \"terraform:https://learn.hashicorp.com/tutorials/terraform/install-cli\"\n        \"docker:https://docs.docker.com/get-docker/\"\n        \"jq:https://stedolan.github.io/jq/download/\"\n        \"yq:https://github.com/mikefarah/yq#install\"\n        \"gh:https://cli.github.com/\"\n    )\n    \n    local missing_tools=()\n    \n    for tool_info in \"${tools[@]}\"; do\n        local tool=$(echo \"$tool_info\" | cut -d: -f1)\n        local url=$(echo \"$tool_info\" | cut -d: -f2-)\n        \n        if ! command -v \"$tool\" &> /dev/null; then\n            missing_tools+=(\"$tool ($url)\")\n        fi\n    done\n    \n    if [[ ${#missing_tools[@]} -gt 0 ]]; then\n        print_error \"Missing required tools:\"\n        for tool in \"${missing_tools[@]}\"; do\n            echo \"  - $tool\"\n        done\n        return 1\n    fi\n    \n    print_success \"All required tools are available\"\n}\n\n# Kubernetes cluster health check\ncheck_cluster_health() {\n    print_step \"Checking Kubernetes cluster health...\"\n    \n    if ! kubectl cluster-info &> /dev/null; then\n        print_error \"Unable to connect to Kubernetes cluster\"\n        return 1\n    fi\n    \n    local nodes_ready=$(kubectl get nodes --no-headers 2>/dev/null | grep -c \" Ready \" || echo \"0\")\n    local nodes_total=$(kubectl get nodes --no-headers 2>/dev/null | wc -l || echo \"0\")\n    \n    if [[ \"$nodes_ready\" -eq 0 ]]; then\n        print_error \"No ready nodes found in cluster\"\n        return 1\n    fi\n    \n    info \"Cluster health: $nodes_ready/$nodes_total nodes ready\"\n    \n    # Check critical system pods\n    local system_pods_not_ready=$(kubectl get pods -n kube-system --no-headers 2>/dev/null | grep -v \" Running \" | grep -v \" Completed \" | wc -l)\n    \n    if [[ \"$system_pods_not_ready\" -gt 0 ]]; then\n        warn \"$system_pods_not_ready system pods are not in Running state\"\n        kubectl get pods -n kube-system --no-headers | grep -v \" Running \" | grep -v \" Completed \"\n    fi\n    \n    print_success \"Kubernetes cluster is healthy\"\n}\n\n# Namespace management\nmanage_namespace() {\n    local namespace=\"$1\"\n    \n    print_step \"Managing namespace: $namespace\"\n    \n    if kubectl get namespace \"$namespace\" &> /dev/null; then\n        info \"Namespace $namespace already exists\"\n    else\n        kubectl create namespace \"$namespace\"\n        success \"Created namespace: $namespace\"\n    fi\n    \n    # Apply resource quotas and limits\n    if [[ -f \"$PROJECT_ROOT/k8s/namespace.yaml\" ]]; then\n        kubectl apply -f \"$PROJECT_ROOT/k8s/namespace.yaml\"\n        success \"Applied namespace configuration\"\n    fi\n}\n\n# Secret management\nmanage_secrets() {\n    local namespace=\"$1\"\n    \n    print_step \"Managing secrets for namespace: $namespace\"\n    \n    # Check if secrets exist\n    local secrets=(\n        \"learning-assistant-secrets\"\n        \"postgres-secrets\"\n        \"redis-secrets\"\n        \"tls-certificates\"\n    )\n    \n    for secret in \"${secrets[@]}\"; do\n        if kubectl get secret \"$secret\" -n \"$namespace\" &> /dev/null; then\n            info \"Secret $secret already exists\"\n        else\n            warn \"Secret $secret does not exist - needs to be created\"\n        fi\n    done\n    \n    # Apply secrets from templates if they don't exist\n    if [[ -f \"$PROJECT_ROOT/k8s/secrets.yaml\" ]]; then\n        # Note: In production, secrets should be managed by external secret managers\n        # This is for development/testing purposes only\n        if [[ \"$ENVIRONMENT\" != \"production\" ]]; then\n            kubectl apply -f \"$PROJECT_ROOT/k8s/secrets.yaml\" -n \"$namespace\"\n            warn \"Applied development secrets - replace with production secrets\"\n        fi\n    fi\n}\n\n# Infrastructure provisioning\nprovision_infrastructure() {\n    print_step \"Provisioning infrastructure with Terraform...\"\n    \n    local terraform_dir=\"$PROJECT_ROOT/terraform\"\n    \n    if [[ ! -d \"$terraform_dir\" ]]; then\n        print_error \"Terraform directory not found: $terraform_dir\"\n        return 1\n    fi\n    \n    cd \"$terraform_dir\"\n    \n    # Initialize Terraform\n    terraform init -upgrade\n    \n    # Validate configuration\n    terraform validate\n    \n    # Plan infrastructure changes\n    terraform plan -var-file=\"environments/${ENVIRONMENT}.tfvars\" -out=\"tfplan\"\n    \n    # Apply infrastructure (with confirmation in interactive mode)\n    if [[ \"${AUTO_APPROVE:-false}\" == \"true\" ]]; then\n        terraform apply -auto-approve \"tfplan\"\n    else\n        read -p \"Apply terraform changes? (y/N): \" -n 1 -r\n        echo\n        if [[ $REPLY =~ ^[Yy]$ ]]; then\n            terraform apply \"tfplan\"\n        else\n            info \"Terraform apply skipped\"\n            return 0\n        fi\n    fi\n    \n    success \"Infrastructure provisioning completed\"\n    cd \"$PROJECT_ROOT\"\n}\n\n# Database migration\nrun_database_migration() {\n    local namespace=\"$1\"\n    \n    print_step \"Running database migrations...\"\n    \n    # Create migration job\n    local migration_job=\"db-migration-$(date +%s)\"\n    \n    kubectl create job \"$migration_job\" \\\n        --from=cronjob/postgres-backup \\\n        -n \"$namespace\" \\\n        --dry-run=client -o yaml | \\\n        yq eval '.spec.template.spec.containers[0].command = [\"npm\", \"run\", \"migrate\"]' | \\\n        kubectl apply -f -\n    \n    # Wait for migration to complete\n    kubectl wait --for=condition=complete job/\"$migration_job\" -n \"$namespace\" --timeout=300s\n    \n    # Check migration status\n    if kubectl get job \"$migration_job\" -n \"$namespace\" -o jsonpath='{.status.conditions[?(@.type==\"Complete\")].status}' | grep -q \"True\"; then\n        success \"Database migration completed successfully\"\n        \n        # Show migration logs\n        kubectl logs job/\"$migration_job\" -n \"$namespace\"\n        \n        # Cleanup migration job\n        kubectl delete job \"$migration_job\" -n \"$namespace\"\n    else\n        print_error \"Database migration failed\"\n        kubectl logs job/\"$migration_job\" -n \"$namespace\"\n        return 1\n    fi\n}\n\n# Application deployment\ndeploy_application() {\n    local namespace=\"$1\"\n    local deployment_strategy=\"${2:-rolling}\"\n    \n    print_step \"Deploying application with $deployment_strategy strategy...\"\n    \n    local helm_chart=\"$PROJECT_ROOT/helm/learning-assistant\"\n    local values_file=\"$PROJECT_ROOT/helm/learning-assistant/values-${ENVIRONMENT}.yaml\"\n    \n    if [[ ! -f \"$values_file\" ]]; then\n        values_file=\"$PROJECT_ROOT/helm/learning-assistant/values.yaml\"\n    fi\n    \n    # Validate Helm chart\n    helm lint \"$helm_chart\" --values \"$values_file\"\n    \n    case \"$deployment_strategy\" in\n        \"rolling\")\n            helm upgrade --install learning-assistant \"$helm_chart\" \\\n                --namespace \"$namespace\" \\\n                --values \"$values_file\" \\\n                --set global.environment=\"$ENVIRONMENT\" \\\n                --set app.image.tag=\"${IMAGE_TAG:-latest}\" \\\n                --wait --timeout=600s\n            ;;\n        \"blue-green\")\n            # Blue-green deployment logic\n            local current_color=$(kubectl get deployment learning-assistant -n \"$namespace\" -o jsonpath='{.metadata.labels.color}' 2>/dev/null || echo \"blue\")\n            local new_color=$([ \"$current_color\" = \"blue\" ] && echo \"green\" || echo \"blue\")\n            \n            helm upgrade --install \"learning-assistant-$new_color\" \"$helm_chart\" \\\n                --namespace \"$namespace\" \\\n                --values \"$values_file\" \\\n                --set global.environment=\"$ENVIRONMENT\" \\\n                --set app.image.tag=\"${IMAGE_TAG:-latest}\" \\\n                --set deployment.suffix=\"$new_color\" \\\n                --wait --timeout=600s\n            \n            # Switch traffic after validation\n            kubectl patch service learning-assistant -n \"$namespace\" -p \"{\\\"spec\\\":{\\\"selector\\\":{\\\"color\\\":\\\"$new_color\\\"}}}\"\n            \n            success \"Blue-green deployment completed - traffic switched to $new_color\"\n            ;;\n        \"canary\")\n            # Canary deployment logic\n            helm upgrade --install learning-assistant-canary \"$helm_chart\" \\\n                --namespace \"$namespace\" \\\n                --values \"$values_file\" \\\n                --set global.environment=\"$ENVIRONMENT\" \\\n                --set app.image.tag=\"${IMAGE_TAG:-latest}\" \\\n                --set deployment.suffix=\"canary\" \\\n                --set app.replicas=1 \\\n                --wait --timeout=600s\n            \n            kubectl apply -f \"$PROJECT_ROOT/k8s/ingress-canary.yaml\" -n \"$namespace\"\n            \n            success \"Canary deployment completed - 10% traffic routing to canary\"\n            ;;\n        *)\n            print_error \"Unknown deployment strategy: $deployment_strategy\"\n            return 1\n            ;;\n    esac\n    \n    success \"Application deployment completed\"\n}\n\n# Health checks and validation\nvalidate_deployment() {\n    local namespace=\"$1\"\n    \n    print_step \"Validating deployment...\"\n    \n    # Check pod status\n    local ready_pods=$(kubectl get pods -n \"$namespace\" -l app=learning-assistant --no-headers 2>/dev/null | grep \" Running \" | wc -l)\n    local total_pods=$(kubectl get pods -n \"$namespace\" -l app=learning-assistant --no-headers 2>/dev/null | wc -l)\n    \n    if [[ \"$ready_pods\" -eq 0 ]]; then\n        print_error \"No running pods found\"\n        kubectl get pods -n \"$namespace\" -l app=learning-assistant\n        return 1\n    fi\n    \n    info \"Pod status: $ready_pods/$total_pods pods running\"\n    \n    # Check service endpoints\n    local service_endpoints=$(kubectl get endpoints learning-assistant-service -n \"$namespace\" -o jsonpath='{.subsets[0].addresses}' 2>/dev/null | jq length 2>/dev/null || echo \"0\")\n    \n    if [[ \"$service_endpoints\" -eq 0 ]]; then\n        print_error \"No service endpoints available\"\n        return 1\n    fi\n    \n    info \"Service endpoints: $service_endpoints available\"\n    \n    # Health check via API\n    local service_url=\"http://$(kubectl get service learning-assistant-service -n \"$namespace\" -o jsonpath='{.spec.clusterIP}'):$(kubectl get service learning-assistant-service -n \"$namespace\" -o jsonpath='{.spec.ports[0].port}')\"\n    \n    if kubectl run health-check-$(date +%s) --rm -i --restart=Never --image=curlimages/curl:latest -- curl -f \"$service_url/api/health\" --connect-timeout 10; then\n        success \"Health check passed\"\n    else\n        print_error \"Health check failed\"\n        return 1\n    fi\n    \n    success \"Deployment validation completed\"\n}\n\n# Monitoring setup\nsetup_monitoring() {\n    local namespace=\"$1\"\n    \n    print_step \"Setting up monitoring stack...\"\n    \n    # Deploy monitoring stack\n    if [[ -f \"$PROJECT_ROOT/k8s/monitoring-stack.yaml\" ]]; then\n        kubectl apply -f \"$PROJECT_ROOT/k8s/monitoring-stack.yaml\" -n \"$namespace\"\n        success \"Monitoring stack deployed\"\n    fi\n    \n    # Wait for monitoring components to be ready\n    kubectl wait --for=condition=available deployment/prometheus -n \"$namespace\" --timeout=300s\n    kubectl wait --for=condition=available deployment/grafana -n \"$namespace\" --timeout=300s\n    \n    success \"Monitoring setup completed\"\n}\n\n# Backup verification\nverify_backup_system() {\n    local namespace=\"$1\"\n    \n    print_step \"Verifying backup system...\"\n    \n    # Check backup cronjobs\n    local backup_jobs=$(kubectl get cronjobs -n \"$namespace\" --no-headers | grep backup | wc -l)\n    \n    if [[ \"$backup_jobs\" -eq 0 ]]; then\n        warn \"No backup cronjobs found\"\n    else\n        info \"Found $backup_jobs backup cronjobs\"\n        kubectl get cronjobs -n \"$namespace\" | grep backup\n    fi\n    \n    # Check backup storage\n    if kubectl get pvc backup-storage-pvc -n \"$namespace\" &> /dev/null; then\n        local storage_size=$(kubectl get pvc backup-storage-pvc -n \"$namespace\" -o jsonpath='{.status.capacity.storage}')\n        info \"Backup storage available: $storage_size\"\n        success \"Backup system verified\"\n    else\n        warn \"Backup storage PVC not found\"\n    fi\n}\n\n# Security validation\nvalidate_security() {\n    local namespace=\"$1\"\n    \n    print_step \"Validating security configuration...\"\n    \n    # Check pod security policies\n    local pods_with_security_context=$(kubectl get pods -n \"$namespace\" -o jsonpath='{.items[*].spec.securityContext}' | grep -c \"runAsNonRoot\" || echo \"0\")\n    info \"Pods with security context: $pods_with_security_context\"\n    \n    # Check network policies\n    local network_policies=$(kubectl get networkpolicies -n \"$namespace\" --no-headers | wc -l)\n    if [[ \"$network_policies\" -eq 0 ]]; then\n        warn \"No network policies found\"\n    else\n        info \"Network policies configured: $network_policies\"\n    fi\n    \n    # Check RBAC\n    local service_accounts=$(kubectl get serviceaccounts -n \"$namespace\" --no-headers | wc -l)\n    local roles=$(kubectl get roles -n \"$namespace\" --no-headers | wc -l)\n    local rolebindings=$(kubectl get rolebindings -n \"$namespace\" --no-headers | wc -l)\n    \n    info \"RBAC resources - ServiceAccounts: $service_accounts, Roles: $roles, RoleBindings: $rolebindings\"\n    \n    success \"Security validation completed\"\n}\n\n# Performance optimization\noptimize_performance() {\n    local namespace=\"$1\"\n    \n    print_step \"Optimizing performance...\"\n    \n    # Check resource utilization\n    kubectl top nodes 2>/dev/null | head -6 || warn \"Metrics server not available\"\n    kubectl top pods -n \"$namespace\" 2>/dev/null | head -10 || warn \"Pod metrics not available\"\n    \n    # Apply autoscaling policies\n    if [[ -f \"$PROJECT_ROOT/k8s/autoscaling.yaml\" ]]; then\n        kubectl apply -f \"$PROJECT_ROOT/k8s/autoscaling.yaml\" -n \"$namespace\"\n        success \"Autoscaling policies applied\"\n    fi\n    \n    success \"Performance optimization completed\"\n}\n\n# Disaster recovery test\ntest_disaster_recovery() {\n    local namespace=\"$1\"\n    \n    print_step \"Testing disaster recovery procedures...\"\n    \n    # Simulate pod failure\n    local test_pod=$(kubectl get pods -n \"$namespace\" -l app=learning-assistant --no-headers | head -1 | awk '{print $1}')\n    \n    if [[ -n \"$test_pod\" ]]; then\n        info \"Simulating pod failure by deleting pod: $test_pod\"\n        kubectl delete pod \"$test_pod\" -n \"$namespace\"\n        \n        # Wait for pod to be recreated\n        sleep 10\n        kubectl wait --for=condition=ready pod -l app=learning-assistant -n \"$namespace\" --timeout=300s\n        \n        success \"Pod recovery test passed\"\n    fi\n    \n    success \"Disaster recovery test completed\"\n}\n\n# Cleanup resources\ncleanup_resources() {\n    local namespace=\"$1\"\n    \n    print_step \"Cleaning up temporary resources...\"\n    \n    # Clean up completed jobs\n    kubectl delete jobs --field-selector status.successful=1 -n \"$namespace\" || true\n    \n    # Clean up old replicasets\n    kubectl delete replicasets --field-selector 'status.replicas=0' -n \"$namespace\" || true\n    \n    # Clean up evicted pods\n    kubectl delete pods --field-selector 'status.phase=Failed' -n \"$namespace\" || true\n    \n    success \"Resource cleanup completed\"\n}\n\n# Generate deployment report\ngenerate_report() {\n    local namespace=\"$1\"\n    local report_file=\"$LOG_DIR/deployment_report_$DATE.json\"\n    \n    print_step \"Generating deployment report...\"\n    \n    local report=$(cat <<EOF\n{\n  \"deployment\": {\n    \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",\n    \"environment\": \"$ENVIRONMENT\",\n    \"namespace\": \"$namespace\",\n    \"cloud_provider\": \"$CLOUD_PROVIDER\",\n    \"kubernetes_cluster\": \"$KUBERNETES_CLUSTER\",\n    \"image_tag\": \"${IMAGE_TAG:-latest}\"\n  },\n  \"resources\": {\n    \"pods\": $(kubectl get pods -n \"$namespace\" -o json | jq '.items | length'),\n    \"services\": $(kubectl get services -n \"$namespace\" -o json | jq '.items | length'),\n    \"deployments\": $(kubectl get deployments -n \"$namespace\" -o json | jq '.items | length'),\n    \"secrets\": $(kubectl get secrets -n \"$namespace\" -o json | jq '.items | length'),\n    \"configmaps\": $(kubectl get configmaps -n \"$namespace\" -o json | jq '.items | length')\n  },\n  \"health\": {\n    \"ready_pods\": $(kubectl get pods -n \"$namespace\" --no-headers | grep -c \" Running \" || echo \"0\"),\n    \"total_pods\": $(kubectl get pods -n \"$namespace\" --no-headers | wc -l),\n    \"service_endpoints\": $(kubectl get endpoints -n \"$namespace\" -o json | jq '[.items[].subsets[]?.addresses // []] | add | length')\n  },\n  \"security\": {\n    \"network_policies\": $(kubectl get networkpolicies -n \"$namespace\" --no-headers | wc -l),\n    \"service_accounts\": $(kubectl get serviceaccounts -n \"$namespace\" --no-headers | wc -l),\n    \"roles\": $(kubectl get roles -n \"$namespace\" --no-headers | wc -l)\n  }\n}\nEOF\n)\n    \n    echo \"$report\" > \"$report_file\"\n    success \"Deployment report generated: $report_file\"\n    \n    # Pretty print summary\n    echo -e \"\\n${BLUE}ðŸ“Š Deployment Summary${NC}\"\n    echo \"$report\" | jq .\n}\n\n# Main deployment workflow\nmain() {\n    local namespace=\"${NAMESPACE:-learning-assistant}\"\n    local deployment_strategy=\"${DEPLOYMENT_STRATEGY:-rolling}\"\n    \n    print_header \"ðŸš€ Learning Assistant Infrastructure Automation\"\n    \n    info \"Starting infrastructure automation for environment: $ENVIRONMENT\"\n    info \"Target namespace: $namespace\"\n    info \"Deployment strategy: $deployment_strategy\"\n    \n    # Pre-deployment checks\n    validate_config\n    check_tools\n    check_cluster_health\n    \n    # Infrastructure setup\n    if [[ \"${SKIP_TERRAFORM:-false}\" != \"true\" ]]; then\n        provision_infrastructure\n    fi\n    \n    # Kubernetes deployment\n    manage_namespace \"$namespace\"\n    manage_secrets \"$namespace\"\n    \n    # Database setup\n    if [[ \"${SKIP_MIGRATION:-false}\" != \"true\" ]]; then\n        run_database_migration \"$namespace\"\n    fi\n    \n    # Application deployment\n    deploy_application \"$namespace\" \"$deployment_strategy\"\n    \n    # Post-deployment validation\n    validate_deployment \"$namespace\"\n    \n    # Additional setup\n    if [[ \"${SETUP_MONITORING:-true}\" == \"true\" ]]; then\n        setup_monitoring \"$namespace\"\n    fi\n    \n    verify_backup_system \"$namespace\"\n    validate_security \"$namespace\"\n    optimize_performance \"$namespace\"\n    \n    # Optional tests\n    if [[ \"${RUN_DR_TEST:-false}\" == \"true\" ]]; then\n        test_disaster_recovery \"$namespace\"\n    fi\n    \n    # Cleanup and reporting\n    cleanup_resources \"$namespace\"\n    generate_report \"$namespace\"\n    \n    print_header \"ðŸŽ‰ Infrastructure Automation Completed Successfully\"\n    success \"All systems deployed and validated\"\n    success \"Logs available at: $LOG_FILE\"\n}\n\n# Script execution\nif [[ \"${BASH_SOURCE[0]}\" == \"${0}\" ]]; then\n    # Set default values if not provided\n    ENVIRONMENT=\"${ENVIRONMENT:-staging}\"\n    CLOUD_PROVIDER=\"${CLOUD_PROVIDER:-aws}\"\n    KUBERNETES_CLUSTER=\"${KUBERNETES_CLUSTER:-learning-assistant-cluster}\"\n    DOMAIN_NAME=\"${DOMAIN_NAME:-learning-assistant.example.com}\"\n    \n    # Run main function with error handling\n    if main \"$@\"; then\n        exit 0\n    else\n        print_error \"Infrastructure automation failed\"\n        exit 1\n    fi\nfi