import fs from 'fs/promises';
import path from 'path';
import crypto from 'crypto';

export interface Vulnerability {
  id: string;
  title: string;
  description: string;
  severity: 'low' | 'moderate' | 'high' | 'critical';
  cvss: number;
  cwe?: string[];
  cve?: string[];
  affectedVersions: string[];
  patchedVersions?: string[];
  exploitability?: 'unproven' | 'poc' | 'functional' | 'high';
  references?: string[];
  discoveredAt: Date;
  lastUpdated: Date;
}

export interface DependencyInfo {
  name: string;
  version: string;
  type: 'production' | 'development' | 'optional' | 'peer';
  path: string;
  directDependency: boolean;
  dependencyChain: string[];
  license?: string;
  repository?: string;
  maintainers?: string[];
  lastUpdate?: Date;
  downloadCount?: number;
}

export interface SecurityReport {
  scanId: string;
  timestamp: Date;
  summary: {
    totalDependencies: number;
    vulnerableDependencies: number;
    criticalVulnerabilities: number;
    highVulnerabilities: number;
    moderateVulnerabilities: number;
    lowVulnerabilities: number;
    securityScore: number;
  };
  vulnerabilities: Array<{
    dependency: DependencyInfo;
    vulnerabilities: Vulnerability[];
  }>;
  recommendations: SecurityRecommendation[];
  complianceStatus: ComplianceStatus;
}

export interface SecurityRecommendation {
  id: string;
  type: 'update' | 'replace' | 'remove' | 'audit' | 'policy';
  priority: 'low' | 'medium' | 'high' | 'critical';
  title: string;
  description: string;
  action: string;
  targetDependency?: string;
  suggestedVersion?: string;
  alternativePackages?: string[];
  effort: 'minimal' | 'moderate' | 'significant' | 'major';
  riskReduction: number;
}

export interface ComplianceStatus {
  score: number;
  checks: Array<{
    name: string;
    passed: boolean;
    description: string;
    severity: 'info' | 'warning' | 'error';
  }>;
}

export interface VulnerabilityDatabase {
  lastUpdated: Date;
  sources: string[];
  vulnerabilities: Map<string, Vulnerability[]>;
}

export class VulnerabilityScanner {
  private database: VulnerabilityDatabase;
  private readonly projectRoot: string;
  private readonly knownVulnerabilities: Map<string, Vulnerability[]> = new Map();
  private readonly packageManagers = ['npm', 'yarn', 'pnpm'];

  constructor(projectRoot: string = process.cwd()) {
    this.projectRoot = projectRoot;
    this.database = {
      lastUpdated: new Date(),
      sources: ['npm-audit', 'snyk', 'osv', 'github-advisory'],
      vulnerabilities: new Map(),
    };
    this.initializeDatabase();
  }

  /**
   * Scan project for vulnerabilities
   */
  async scanProject(): Promise<SecurityReport> {
    const scanId = this.generateScanId();
    const timestamp = new Date();

    console.log('Starting security scan...');

    // Load dependencies
    const dependencies = await this.loadDependencies();
    console.log(`Found ${dependencies.length} dependencies`);

    // Check for vulnerabilities
    const vulnerablePackages = await this.checkVulnerabilities(dependencies);
    console.log(`Found ${vulnerablePackages.length} packages with vulnerabilities`);

    // Generate summary
    const summary = this.generateSummary(dependencies, vulnerablePackages);

    // Generate recommendations
    const recommendations = this.generateRecommendations(vulnerablePackages);

    // Check compliance
    const complianceStatus = await this.checkCompliance(dependencies, vulnerablePackages);

    const report: SecurityReport = {
      scanId,
      timestamp,
      summary,
      vulnerabilities: vulnerablePackages,
      recommendations,
      complianceStatus,
    };

    console.log(`Security scan completed. Score: ${summary.securityScore}/100`);
    return report;
  }

  /**
   * Load project dependencies
   */
  private async loadDependencies(): Promise<DependencyInfo[]> {
    const dependencies: DependencyInfo[] = [];

    // Load from package.json
    const packageJson = await this.loadPackageJson();
    if (packageJson) {
      dependencies.push(...await this.parsePackageJson(packageJson));
    }

    // Load from lock files
    const lockFile = await this.loadLockFile();
    if (lockFile) {
      dependencies.push(...await this.parseLockFile(lockFile));
    }

    // Deduplicate
    const uniqueDependencies = this.deduplicateDependencies(dependencies);

    return uniqueDependencies;
  }

  /**
   * Check dependencies for vulnerabilities
   */
  private async checkVulnerabilities(
    dependencies: DependencyInfo[]
  ): Promise<Array<{ dependency: DependencyInfo; vulnerabilities: Vulnerability[] }>> {
    const vulnerablePackages: Array<{ dependency: DependencyInfo; vulnerabilities: Vulnerability[] }> = [];

    for (const dependency of dependencies) {
      const vulnerabilities = await this.getVulnerabilitiesForPackage(dependency);
      if (vulnerabilities.length > 0) {
        vulnerablePackages.push({ dependency, vulnerabilities });
      }
    }

    return vulnerablePackages;
  }

  /**
   * Get vulnerabilities for a specific package
   */
  private async getVulnerabilitiesForPackage(dependency: DependencyInfo): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Check known vulnerabilities
    const knownVulns = this.knownVulnerabilities.get(dependency.name) || [];
    for (const vuln of knownVulns) {
      if (this.isVersionAffected(dependency.version, vuln.affectedVersions)) {
        vulnerabilities.push(vuln);
      }
    }

    // Check npm audit (simulated)
    const npmVulns = await this.checkNpmAudit(dependency);
    vulnerabilities.push(...npmVulns);

    // Check additional sources
    const additionalVulns = await this.checkAdditionalSources(dependency);
    vulnerabilities.push(...additionalVulns);

    return this.deduplicateVulnerabilities(vulnerabilities);
  }

  /**
   * Generate security summary
   */
  private generateSummary(
    dependencies: DependencyInfo[],
    vulnerablePackages: Array<{ dependency: DependencyInfo; vulnerabilities: Vulnerability[] }>
  ): SecurityReport['summary'] {
    let criticalVulns = 0;
    let highVulns = 0;
    let moderateVulns = 0;
    let lowVulns = 0;

    vulnerablePackages.forEach(({ vulnerabilities }) => {
      vulnerabilities.forEach(vuln => {
        switch (vuln.severity) {
          case 'critical':
            criticalVulns++;
            break;
          case 'high':
            highVulns++;
            break;
          case 'moderate':
            moderateVulns++;
            break;
          case 'low':
            lowVulns++;
            break;
        }
      });
    });

    // Calculate security score (0-100)
    const totalVulns = criticalVulns + highVulns + moderateVulns + lowVulns;
    const criticalWeight = criticalVulns * 25;
    const highWeight = highVulns * 10;
    const moderateWeight = moderateVulns * 5;
    const lowWeight = lowVulns * 1;
    const totalWeight = criticalWeight + highWeight + moderateWeight + lowWeight;
    
    const securityScore = Math.max(0, 100 - totalWeight);

    return {
      totalDependencies: dependencies.length,
      vulnerableDependencies: vulnerablePackages.length,
      criticalVulnerabilities: criticalVulns,
      highVulnerabilities: highVulns,
      moderateVulnerabilities: moderateVulns,
      lowVulnerabilities: lowVulns,
      securityScore: Math.round(securityScore),
    };
  }

  /**
   * Generate security recommendations
   */
  private generateRecommendations(
    vulnerablePackages: Array<{ dependency: DependencyInfo; vulnerabilities: Vulnerability[] }>
  ): SecurityRecommendation[] {
    const recommendations: SecurityRecommendation[] = [];

    vulnerablePackages.forEach(({ dependency, vulnerabilities }) => {
      const criticalVulns = vulnerabilities.filter(v => v.severity === 'critical');
      const highVulns = vulnerabilities.filter(v => v.severity === 'high');

      if (criticalVulns.length > 0) {
        recommendations.push({
          id: `critical-${dependency.name}`,
          type: 'update',
          priority: 'critical',
          title: `Critical vulnerabilities in ${dependency.name}`,
          description: `${criticalVulns.length} critical vulnerabilities found`,
          action: `Update ${dependency.name} immediately`,
          targetDependency: dependency.name,
          suggestedVersion: this.getSuggestedVersion(dependency, vulnerabilities),
          effort: 'minimal',
          riskReduction: 95,
        });
      } else if (highVulns.length > 0) {
        recommendations.push({
          id: `high-${dependency.name}`,
          type: 'update',
          priority: 'high',
          title: `High severity vulnerabilities in ${dependency.name}`,
          description: `${highVulns.length} high severity vulnerabilities found`,
          action: `Update ${dependency.name} as soon as possible`,
          targetDependency: dependency.name,
          suggestedVersion: this.getSuggestedVersion(dependency, vulnerabilities),
          effort: 'minimal',
          riskReduction: 80,
        });
      }

      // Check for outdated packages
      if (this.isPackageOutdated(dependency)) {
        recommendations.push({
          id: `outdated-${dependency.name}`,
          type: 'update',
          priority: 'medium',
          title: `Outdated package: ${dependency.name}`,
          description: 'Package is significantly outdated',
          action: 'Consider updating to the latest version',
          targetDependency: dependency.name,
          effort: 'moderate',
          riskReduction: 20,
        });
      }

      // Check for deprecated packages
      if (this.isPackageDeprecated(dependency)) {
        recommendations.push({
          id: `deprecated-${dependency.name}`,
          type: 'replace',
          priority: 'medium',
          title: `Deprecated package: ${dependency.name}`,
          description: 'Package is deprecated and should be replaced',
          action: 'Find an alternative package',
          targetDependency: dependency.name,
          alternativePackages: this.getAlternativePackages(dependency.name),
          effort: 'significant',
          riskReduction: 60,
        });
      }
    });

    // Add general recommendations
    recommendations.push(...this.getGeneralRecommendations());

    return recommendations.sort((a, b) => {
      const priorityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
      return priorityOrder[b.priority] - priorityOrder[a.priority];
    });
  }

  /**
   * Check compliance with security standards
   */
  private async checkCompliance(
    dependencies: DependencyInfo[],
    vulnerablePackages: Array<{ dependency: DependencyInfo; vulnerabilities: Vulnerability[] }>
  ): Promise<ComplianceStatus> {
    const checks = [
      {
        name: 'No Critical Vulnerabilities',
        passed: !vulnerablePackages.some(({ vulnerabilities }) =>
          vulnerabilities.some(v => v.severity === 'critical')
        ),
        description: 'Project should not contain dependencies with critical vulnerabilities',
        severity: 'error' as const,
      },
      {
        name: 'Limited High Severity Vulnerabilities',
        passed: vulnerablePackages.filter(({ vulnerabilities }) =>
          vulnerabilities.some(v => v.severity === 'high')
        ).length <= 2,
        description: 'Project should have minimal high severity vulnerabilities',
        severity: 'warning' as const,
      },
      {
        name: 'No Deprecated Dependencies',
        passed: !dependencies.some(dep => this.isPackageDeprecated(dep)),
        description: 'Project should not use deprecated packages',
        severity: 'warning' as const,
      },
      {
        name: 'Dependency Lock File Present',
        passed: await this.hasLockFile(),
        description: 'Project should have a lock file for reproducible builds',
        severity: 'warning' as const,
      },
      {
        name: 'Regular Security Audits',
        passed: true, // Assume this check passes if we're running the scanner
        description: 'Project should have regular security audits',
        severity: 'info' as const,
      },
    ];

    const passedChecks = checks.filter(check => check.passed).length;
    const score = Math.round((passedChecks / checks.length) * 100);

    return { score, checks };
  }

  /**
   * Helper methods
   */
  private async loadPackageJson(): Promise<any | null> {
    try {
      const packagePath = path.join(this.projectRoot, 'package.json');
      const content = await fs.readFile(packagePath, 'utf8');
      return JSON.parse(content);
    } catch (error) {
      console.warn('Could not load package.json:', error);
      return null;
    }
  }

  private async loadLockFile(): Promise<any | null> {
    const lockFiles = ['package-lock.json', 'yarn.lock', 'pnpm-lock.yaml'];
    
    for (const lockFile of lockFiles) {
      try {
        const lockPath = path.join(this.projectRoot, lockFile);
        const content = await fs.readFile(lockPath, 'utf8');
        
        if (lockFile.endsWith('.json')) {
          return JSON.parse(content);
        } else {
          return { content, type: lockFile };
        }
      } catch (error) {
        // Continue to next lock file
      }
    }
    
    return null;
  }

  private async parsePackageJson(packageJson: any): Promise<DependencyInfo[]> {
    const dependencies: DependencyInfo[] = [];
    
    const addDependencies = (deps: Record<string, string>, type: DependencyInfo['type']) => {
      Object.entries(deps || {}).forEach(([name, version]) => {
        dependencies.push({
          name,
          version: version.replace(/^[\^~>=<]/, ''), // Remove version prefixes
          type,
          path: `node_modules/${name}`,
          directDependency: true,
          dependencyChain: [name],
        });
      });
    };

    addDependencies(packageJson.dependencies, 'production');
    addDependencies(packageJson.devDependencies, 'development');
    addDependencies(packageJson.optionalDependencies, 'optional');
    addDependencies(packageJson.peerDependencies, 'peer');

    return dependencies;
  }

  private async parseLockFile(lockFile: any): Promise<DependencyInfo[]> {
    // Simplified lock file parsing - in a real implementation,
    // you'd properly parse different lock file formats
    return [];
  }

  private deduplicateDependencies(dependencies: DependencyInfo[]): DependencyInfo[] {
    const seen = new Map<string, DependencyInfo>();
    
    dependencies.forEach(dep => {
      const key = `${dep.name}@${dep.version}`;
      if (!seen.has(key)) {
        seen.set(key, dep);
      }
    });
    
    return Array.from(seen.values());
  }

  private deduplicateVulnerabilities(vulnerabilities: Vulnerability[]): Vulnerability[] {
    const seen = new Set<string>();
    return vulnerabilities.filter(vuln => {
      if (seen.has(vuln.id)) {
        return false;
      }
      seen.add(vuln.id);
      return true;
    });
  }

  private isVersionAffected(version: string, affectedVersions: string[]): boolean {
    // Simplified version checking - in a real implementation,
    // you'd use a proper semver library
    return affectedVersions.some(range => version.includes(range));
  }

  private async checkNpmAudit(dependency: DependencyInfo): Promise<Vulnerability[]> {
    // Simulate npm audit check
    // In a real implementation, you'd call npm audit API or run npm audit command
    return [];
  }

  private async checkAdditionalSources(dependency: DependencyInfo): Promise<Vulnerability[]> {
    // Check additional vulnerability sources (GitHub Advisory, Snyk, etc.)
    return [];
  }

  private getSuggestedVersion(dependency: DependencyInfo, vulnerabilities: Vulnerability[]): string {
    // Find the lowest version that fixes all vulnerabilities
    const patchedVersions = vulnerabilities.flatMap(v => v.patchedVersions || []);
    return patchedVersions.length > 0 ? patchedVersions[0] : 'latest';
  }

  private isPackageOutdated(dependency: DependencyInfo): boolean {
    // In a real implementation, you'd check the package registry for the latest version
    return false;
  }

  private isPackageDeprecated(dependency: DependencyInfo): boolean {
    // Check if package is deprecated
    return false;
  }

  private getAlternativePackages(packageName: string): string[] {
    // Return alternative packages for deprecated ones
    const alternatives: Record<string, string[]> = {
      'request': ['axios', 'node-fetch', 'got'],
      'left-pad': ['pad-left'],
      // Add more mappings
    };
    
    return alternatives[packageName] || [];
  }

  private getGeneralRecommendations(): SecurityRecommendation[] {
    return [
      {
        id: 'enable-audit-signatures',
        type: 'policy',
        priority: 'medium',
        title: 'Enable npm audit signatures',
        description: 'Configure npm to verify package signatures',
        action: 'Run: npm config set audit-level moderate',
        effort: 'minimal',
        riskReduction: 10,
      },
      {
        id: 'regular-updates',
        type: 'policy',
        priority: 'low',
        title: 'Establish regular update schedule',
        description: 'Create a schedule for regular dependency updates',
        action: 'Set up automated dependency updates',
        effort: 'moderate',
        riskReduction: 30,
      },
    ];
  }

  private async hasLockFile(): Promise<boolean> {
    const lockFiles = ['package-lock.json', 'yarn.lock', 'pnpm-lock.yaml'];
    
    for (const lockFile of lockFiles) {
      try {
        const lockPath = path.join(this.projectRoot, lockFile);
        await fs.access(lockPath);
        return true;
      } catch (error) {
        // Continue to next lock file
      }
    }
    
    return false;
  }

  private generateScanId(): string {
    return crypto.randomBytes(16).toString('hex');
  }

  private initializeDatabase(): void {
    // Initialize with some known vulnerabilities
    // In a real implementation, this would load from external sources
    this.loadKnownVulnerabilities();
  }

  private loadKnownVulnerabilities(): void {
    // Example vulnerabilities - in practice, load from databases
    const exampleVulnerabilities: Array<{ package: string; vulnerabilities: Vulnerability[] }> = [
      {
        package: 'lodash',
        vulnerabilities: [
          {
            id: 'lodash-prototype-pollution',
            title: 'Prototype Pollution in lodash',
            description: 'lodash versions prior to 4.17.12 are vulnerable to Prototype Pollution',
            severity: 'high',
            cvss: 7.5,
            cve: ['CVE-2019-10744'],
            affectedVersions: ['<4.17.12'],
            patchedVersions: ['>=4.17.12'],
            discoveredAt: new Date('2019-07-26'),
            lastUpdated: new Date('2019-07-26'),
          },
        ],
      },
    ];

    exampleVulnerabilities.forEach(({ package: pkgName, vulnerabilities }) => {
      this.knownVulnerabilities.set(pkgName, vulnerabilities);
    });
  }

  /**
   * Update vulnerability database
   */
  async updateDatabase(): Promise<void> {
    console.log('Updating vulnerability database...');
    
    // In a real implementation, this would:
    // 1. Fetch from npm audit API
    // 2. Download GitHub Advisory Database
    // 3. Sync with Snyk database
    // 4. Update OSV database
    
    this.database.lastUpdated = new Date();
    console.log('Vulnerability database updated');
  }

  /**
   * Export report to different formats
   */
  exportReport(report: SecurityReport, format: 'json' | 'html' | 'sarif' = 'json'): string {
    switch (format) {
      case 'json':
        return JSON.stringify(report, null, 2);
      
      case 'html':
        return this.generateHTMLReport(report);
      
      case 'sarif':
        return this.generateSARIFReport(report);
      
      default:
        throw new Error(`Unsupported export format: ${format}`);
    }
  }

  private generateHTMLReport(report: SecurityReport): string {
    // Generate HTML report
    return `
      <!DOCTYPE html>
      <html>
        <head>
          <title>Security Report - ${report.scanId}</title>
          <style>
            body { font-family: Arial, sans-serif; margin: 20px; }
            .critical { color: #d32f2f; }
            .high { color: #f57c00; }
            .moderate { color: #fbc02d; }
            .low { color: #388e3c; }
            .score { font-size: 2em; font-weight: bold; }
          </style>
        </head>
        <body>
          <h1>Security Report</h1>
          <p>Scan ID: ${report.scanId}</p>
          <p>Timestamp: ${report.timestamp.toISOString()}</p>
          <div class="score">Security Score: ${report.summary.securityScore}/100</div>
          <h2>Summary</h2>
          <ul>
            <li>Total Dependencies: ${report.summary.totalDependencies}</li>
            <li>Vulnerable Dependencies: ${report.summary.vulnerableDependencies}</li>
            <li class="critical">Critical: ${report.summary.criticalVulnerabilities}</li>
            <li class="high">High: ${report.summary.highVulnerabilities}</li>
            <li class="moderate">Moderate: ${report.summary.moderateVulnerabilities}</li>
            <li class="low">Low: ${report.summary.lowVulnerabilities}</li>
          </ul>
          <!-- Add more sections as needed -->
        </body>
      </html>
    `;
  }

  private generateSARIFReport(report: SecurityReport): string {
    // Generate SARIF (Static Analysis Results Interchange Format) report
    const sarif = {
      version: '2.1.0',
      $schema: 'https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json',
      runs: [
        {
          tool: {
            driver: {
              name: 'Learning Assistant Security Scanner',
              version: '1.0.0',
            },
          },
          results: report.vulnerabilities.flatMap(({ dependency, vulnerabilities }) =>
            vulnerabilities.map(vuln => ({
              ruleId: vuln.id,
              message: {
                text: vuln.description,
              },
              level: this.severityToSARIFLevel(vuln.severity),
              locations: [
                {
                  physicalLocation: {
                    artifactLocation: {
                      uri: 'package.json',
                    },
                  },
                },
              ],
            }))
          ),
        },
      ],
    };

    return JSON.stringify(sarif, null, 2);
  }

  private severityToSARIFLevel(severity: string): string {
    switch (severity) {
      case 'critical':
      case 'high':
        return 'error';
      case 'moderate':
        return 'warning';
      case 'low':
        return 'note';
      default:
        return 'info';
    }
  }
}

// Export singleton instance
export const vulnerabilityScanner = new VulnerabilityScanner();